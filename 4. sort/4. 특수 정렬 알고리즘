
4. 특수 정렬 알고리즘

- 입력 원소들이 특수한 성질을 만족하는 경우 O(nlogn)의 한계를 극복할 수 있음

1. 기수정렬(Radix Sort)
- 입력이 모두 k 자릿수 이하의 자연수인 특수한 경우(자연수가 아닌 제한된 종류를 가진 알파벳도 해당)
- O(n)시간 소요

radixSort(A[],n,k){ //원소들이 각각 최대 k자릿수, 가장 낮은 자릿수가 1번째 자릿수
  for i<-1 to k
    i번째 자릿수에 대해 A[1...n]을 안정성을 유지하면서 정렬;
}

- 안정성을 유지하면서 정렬한다= 값이 같은 원소끼리는 정렬 후 우너래의 순서가 바뀌지 않는 성질(stable sort)_예: 2150, 2154의 4번째 자리 정렬
- 단, 자릿수별 정렬 시 앞의 비교정렬 알고리즘 사용하면 수행시간이 O(n)초과 -> 0부터 9까지 표시된 10개의 공간을 미리 준비해두고 각각의 수를 가진 입력은 해당 공간에 차례대로 넣어줌(k번 반복)


2. 계수정렬(Counting Sort)
- A[1...n]의 원소들이 k를 넘지 않는 자연수인 경우: 1부터 k까지의 자연수가 각각 몇번 나타나는지를 counting->원소의 위치 계산

countingSort(A[], B[], n){ //A[1...n]: 입력배열, B[1...n]: 정렬결과
  for i<-1 to k
    C[i]=0;
  for j<-1 to n
    C[A[j]]++; //C[i]: 값이 i인 원소의 갯수
  for i<-2 to k
    C[i]=C[i]+C[i-1]; //C[i]: i보다 작거나 같은 원소의 갯수
  for j<-n downto 1{
    B[C[A[j]]] = A[j]; //C[] 정보를 이용하여 위치 계산
    C[A[j]]--;
  }
}

- 수행시간: O(n) (=O(k)+O(n)+O(k)+O(n))
: (k가 O(n)인 경우) O(n), (k가 O(n)을 초과하는 경우) O(k), (k가 O(nlogn)을 초과하는 경우) 병합/퀵/힙 정렬보다 못함
-> 계수정렬은 k가 O(n)을 초과하지 않는 경우 사용하기
