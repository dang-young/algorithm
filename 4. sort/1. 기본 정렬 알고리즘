* 정렬: n개의 원소를 순서대로 배열하는 것
* 수행시간에 따른 분류
1. O(n^2): 기본적인 정렬 알고리즘
2. O(nlogn): 효율적 정렬 알고리즘
3. O(n): 고효율 정렬 알고리즘(입력이 특수한 조건을 만족하는 경우)

[1. 기본적인 정렬 알고리즘]
1. 선택 정렬(Selection Sort)

selectionSort(A[], n){
  for last <- n downto 2{
    k <- the Largest(A, last);
    A[k] <-> A[last];
  }
}

- 배열 A[1...n]에서 가장 큰 원소를 찾는다 -> 해당 원소와 A[n] 자리를 바꾼다.
-> 배열 A[1...n-1]에서 가장 큰 원소를 찾는다 -> 해당 원소와 A[n-1] 자리를 바꾼다.
... -> 배열 A[1,2]에서 가장 큰 원소를 찾는다 -> 해당 원소와 A[2] 자리를 바꾼다. -> A[1]에는 최소값이 위치한다.-> 정렬을 끝낸다.
- 수행시간: O(n^2)
: 수를 비교하는 횟수 = (n-1)+(n-2)+...+(1) = n(n-1)/2


2. 버블 정렬(Bubble Sort)

bubbleSort(A[], n){
  for last<-n downto 2
    for i<-1 to last-1
      if(A[i]>A[i+1]) then A[i]<->A[i+1];
}

- 기본적인 아이디어(가장 큰 원소를 rightmost position으로 옮긴다)는 선택 정렬과 동일
- 단, 전체를 스캔해서 최댓값을 찾는 선택정렬과 달리 
버블 정렬은 왼쪽부터 adjecet element와의 비교->swap 을 통해 최댓값을 오른쪽으로 옮긴다.
- 수행시간: O(n^2)
: 수를 비교하는 횟수 = (n-1)+(n-2)+...+(1) = n(n-1)/2
- 팁: 이미 정렬된 배열인 경우 swap이 0번 발생함을 이용 -> boolean 변수 sorted를 이용하여 swap이 한번도 발생하지 않은 경우 loop에서 탈출하도록 구현->수행시간을 줄일 수 있음


3. 삽입 정렬(Insertion Sort)

insertionSort(A[], n){
  for i<-2 to n
    A[1...i]의 적합한 자리에 A[i]를 삽입 //구체적으로는 A[i]값이 비교값보다 작은 경우 한칸씩 뒤로 미룸
}

- i=2 부터 n까지 A[i]의 원소를 A[1...i] 중 적합한 자리에 준다. 단, 이 때 A[1...i-1]은 정렬되어 있다.
- 수행시간: O(n^2)
: 수를 비교하는 횟수 = 1+2+...+(n-1) = n(n-1)/2
-  단, 배열이 거의 정렬된 상태로 입력되는 경우 약 O(n)의 시간이 소요된다.(버블정렬과 달리 별도의 코드 불필요->오버헤드X)

=> 정리
- 선택정렬, 버블정렬: n개 배열에서 시작하여 아직 정렬되지 않은 배열의 크기를 하나씩 줄임
- 삽입정렬: 1개의 배열에서 시작하여 정렬된 배열의 크기를 하나씩 늘림
