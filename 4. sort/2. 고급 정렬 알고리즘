
[2. 고급 정렬 알고리즘]

- 병합 정렬, 퀵 정렬, 힙 정렬 소개
- 평균 O(nlogn) 시간 소요, 퀵 정렬은 O(n^2) 소요
※ 기본 정렬 알고리즘은 O(n^2) 시간 소요
※ 퀵 정렬의 경우 실무에서 가장 많이 사용되는 정렬로 평균성능은 타 정렬에 비해 뒤떨어지지 않음

1. 병합 정렬(Merge Sort)

mergeSort(A[], p, r){
  if(p<r) then{
    q<-(p+r)/2
    mergeSort(A, p, q)
    mergeSort(A, q+1, r)
    merge(A, p, q, r) //정렬된 두 배열을 병합
  }
}
- 병합 정렬은 자신에 비해 크기가 반인 문제를 두개 푼 다음, 각각을 병합하는 일을 재귀적으로 반복
- 수행시간: O(nlogn)
: 유도과정
T(n) <= a (if n=1)
        2T(n/2)+cn (if n>1) //c: 병합에 드는 시간
n = 2^k로 가정할 경우 
T(n) <= 2T(n/2)+cn <=2(2T(n/4)+cn/2)+cn<=....<= 2^kT(n/2^k)+kcn
                                                = nT(1)+kcn = an+cnlogn = O(nlogn)
                                                
2. 퀵 정렬(Quick Sort)

quickSort(A[],p,r){
  if(p<r) then{
    q<-partition(A,p,r); //분할(A[r] 원소를 기준으로 A[p...r]의 원소를 재배치-작은 것은 왼쪽, 큰 것은 오른쪽)
    quickSort(A,p,q-1); //왼쪽 배열 정렬
    quickSort(A,q+1,r); //오른쪽 배열 정렬
  }
}

- 평균적으로 가장 좋은 성능을 가지므로 현장에서 가장 많이 쓰는 정렬 알고리즘
- 병합정렬과 마찬가지로 재귀호출을 사용하나 병합정렬은 작은문제 해결->후처리, 퀵정렬은 선행작업->작은문제 해결 순으로 문제를 해결
- partition() 아이디어
(1) 배열을 4구역으로 나누어 관리
(2) 1구역: A[r]보다 작은 값(변수i: 1구역의 끝)
(3) 2구역: A[r]보다 큰 값
(4) 3구역: 아직 보지 않은 값(변수j: 3구역의 시작)
(5) 4구역: A[r]
(6) for 루프 1번 돌 때: 3구역은 한칸씩 줄어듦/1구역 또는 2구역은 한칸 늘어남/2구역이 늘어날때는 j만 1증가/1구역이 늘어날 때는 i,j 모두 1 증가(swap 발생)
- 수행시간: 최선+평균_O(nlogn)..항상 반씩 partition
           최악_O(n^2)..항상 한쪽으로 몰리도록 partition
