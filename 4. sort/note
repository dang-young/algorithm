* 정렬: n개의 원소를 순서대로 배열하는 것
* 수행시간에 따른 분류
1. O(n^2): 기본적인 정렬 알고리즘
2. O(nlogn): 효율적 정렬 알고리즘
3. O(n): 고효율 정렬 알고리즘(입력이 특수한 조건을 만족하는 경우)

[1. 기본적인 정렬 알고리즘]
1. 선택 정렬(Selection Sort)

selectionSort(A[], n){
  for last <- n downto 2{
    k <- the Largest(A, last);
    A[k] <-> A[last];
  }
}

- 배열 A[1...n]에서 가장 큰 원소를 찾는다 -> 해당 원소와 A[n] 자리를 바꾼다.
-> 배열 A[1...n-1]에서 가장 큰 원소를 찾는다 -> 해당 원소와 A[n-1] 자리를 바꾼다.
... -> 배열 A[1,2]에서 가장 큰 원소를 찾는다 -> 해당 원소와 A[2] 자리를 바꾼다. -> A[1]에는 최소값이 위치한다.-> 정렬을 끝낸다.
- 수행시간: O(n^2)
: 수를 비교하는 횟수 = (n-1)+(n-2)+...+(1) = n(n-1)/2


2. 버블 정렬(Bubble Sort)

bubbleSort(A[], n){
  for last<-n downto 2
    for i<-1 to last-1
      if(A[i]>A[i+1]) then A[i]<->A[i+1];
}

- 기본적인 아이디어(가장 큰 원소를 rightmost position으로 옮긴다)는 선택 정렬과 동일
- 단, 전체를 스캔해서 최댓값을 찾는 선택정렬과 달리 
버블 정렬은 왼쪽부터 adjecet element와의 비교->swap 을 통해 최댓값을 오른쪽으로 옮긴다.
- 수행시간: O(n^2)
: 수를 비교하는 횟수 = (n-1)+(n-2)+...+(1) = n(n-1)/2
- 팁: 이미 정렬된 배열인 경우 swap이 0번 발생함을 이용 -> boolean 변수 sorted를 이용하여 swap이 한번도 발생하지 않은 경우 loop에서 탈출하도록 구현->수행시간을 줄일 수 있음



3. 삽입 정렬(Insertion Sort)
